---
layout: post
title: CompSci 335 notes
category: uni
excerpt:
---

##Spring framework
####IoC
- Interfaces improve extensibility and flexibility
- IoC allows component implementations and binding requirements to be manages separately from application code
- DI involved IoC container injecting dependencies into components through constructor/setter injection
- IoC containers offer service interfaces (eg. ApplicationContext) to interact with them

####AOP
- AOP allows more effective management of cross-cutting concerns
- Spring uses dynamic AOP where advice is woven at run time via proxies
- Spring allows several types of advice (@Before, @AfterReturning, @Around, @AfterThrowing, etc)
- pointcuts identify the precise joinpoint where the advice should be inserted
- Introductions allow objects to implement additional interfaces at runtime
- dynamic proxies contain invocation handlers that apply advice (basis of AOP proxies)

####RMI + Distributed Objects
- the aim of RMI is to hide the details of invoking a method over a server, so it is the same as a local method to the developer
- however it is necessarily different - parameters must be serialized, there is additional runtime overhead, remote calls can fail
- client invokes methods on local proxy objects
- serializes/marshals the object/arguments -> turns memory references into handles (class handle, object handle), and outputs as a byte stream

####Web Services
- HTTP is an open, stateless, request-reply standard
- SOAP (simple object access protocol)
	- uses XML
	- WSDL (web service description language) uses XML to describe the web service (service contract), includes datatypes, messages, operations etc
	- action-focused
- REST (representational state transfer)
	- resource-focused
	- relatively lightweight
- Spring allows abstraction above HTTP, achieving separation of concerns and reducing boilerplate code

####Data Access
- DAO (data access object) reads/writes the database
- DAO interfaces allow testability + modifiability
- Data sources can be:
	- pooled: many active connections, threads can request one to use
	- on demand: new connection created when needed
	- singleton: one connection, suitable for small applications
- Simple JDBC (w/ spring)
	- Uses tired and tested SQL. Direct manipulation of tables, rows, columns
	- Complexity grows with persistence requirements
- ORM (object relational mapping)
	- automates mapping between objects and SQL structures
	- automates SQL query generation
	- allows developers to focus on application logic in terms of objects

####Transactions
- Transactions deal with currency control problems
	- lost updates (`T:x.setBalance, U:x.setBalance`)
	- inconsistent retrieval (`T:x.withdraw, U:x.getBalance+y.getBalance, T:y.setBalance`)	
- by default each individual SQL statement is a transaction, we need the client to be able to specify the transaction start/end
- RMI clients use middleware API to specify  transaction boundaries on RMI calls.
- ACID
	- __A__tomicity: transaction either completes successfully, or fails with _NO_ effect
	- __C__onsistency: transaction takes system from one consistent state to another
	- __I__solation: one transaction cannot interfere with others
	- __D__urability: after successful transaction all effects are saved in permanent storage
- _Serially equivalent_ interleaving -- has the same effect when run concurrently or serially
	- all pairs of conflicting operations must be executed in the same order at all the objects they both access (read-write, write-read, write-write)
- aborting
	- _dirty reads_ -- U sees write of T before T aborts; fix by _cascading aborts_
	- _premature writes_ -- leads to inconsistent data where a transaction aborts; keep a 'before image' snapshot, delay write operations until other transactions commit/abort
- exclusive locks -- fixes all 4 problems but slow the DB
- _read/write locks_
	- read lock _sharing_: multiple transactions can hold a read lock on the same object
	- lock _promotion_: read lock can be promoted to write lock

| lock set 	| req read 	| req write |
| :------- 	| :------- 	| :-------- |
| none		| OK 		| OK		|
| read 		| OK 		| WAIT		|
| write 	| WAIT 		| WAIT		|

- deadlock:
	- prevent: 
		- acquire all locks _atomically_ (restrictive, may be unknown)
		- request in a predefined order (difficult)
	- timeout (simple)
	- detection and removal (find cycles in waiting-for graph)
- distributed transactions (over multiple servers) require a 2-phase commit, managed by a transaction manager
- spring allows us to specify transactions _declaratively_, spring will do all the hard work
	- `<tx:annotation-driven transaction-manager="txManager"/>`
	- `@Transactional public void updateXYZ() { ... }` 
- propogation =
	- `REQUIRED` -- must use a transaction, will use existing (if exists) [default]
	- `MANDATORY` will only use an existing; `REQUIRES_NEW`
	- `SUPPORTS` will use (if exists) or wont
	- `NOT_SUPPORTED`; `NEVER` (throws ex)
- isolation =
	- `READ_UNCOMMITTED` (breaks ACID isolation),
	- `READ_COMMITTED` (repeatable reads can occur i.e. val changes mid transaction due to other trans commit),
	- `REPEATABLE_READ` (fixes this, but phantom reads still possible i.e. see different rows if other trans added),
	- `SERIALIZABLE` (concurrent at cost of performance)
- `rollback-for <T> extends Exception`

####Security
- _symmetric encryption_: each party uses the _same_ key -- must be kept secret (not easy)
- DES (data encryption standard) uses 56-bit key -- far to easy to bruteforce
- AES (advanced encryption standard) 128-bit key
- public key _asymmetric encryption_, uses public-private key pairs
- __authentication__ methods
	1. unencrypted -- anyone can imitate anyone `Hi, I'm Alice`
	2. verify IP -- anyone can spoof `Hi, I'm 192.168.2.33`
	3. password with symmetric key -- anyone can record the encrypted message `Hi, I'm Alice {pw}K_ab`
	4. use a __nonce__ (one time number) A:`Hi, I'm Alice`, B:`nonce R`, A:`{R}K_ab` -- good, but we still need to keep that key "secret"
	5. public key cryptography
		- A: `Hi, I'm Alice`
		- B: `nonce R`
		- A: `{R}K_A-priv`	-- encrypt with your private key
		- B: `send me K_A-pub`	-- request for your public key
		- A: `K_A-pub`
		- leaves us open for a _man-in-the-middle_ attack
			- since B does not already know `K_A-pub`, M can pretend to be A (to B) and pretend to be B (to A)
- authentication systems are only as secure and the mechanisms for distributing keys!!
- message __integrity__
	- checksums are _insufficient_ for guaranteeing message integrity
	- _digital signature_ uses private key to encrypt the message
	- _message digest_
		- use _secure hash function_ (always gens a unique digest), private-key encrypt the digest and attach to the message
		- receiver will compute the digest (using same function), and compare it to your (public-key) decrypted digest
- _Certificates_
	- CA public keys are assumed to be well-known (maintained by OS, browser, etc)
	- built from `Entity ID + K_Entity-pub` signed by `K_CA-priv`
	- now instead of requesting `K_A-pub` we can request the _public key certificate_
- __SSL__
	- server sends _certificate_ to the client
	- client verifies `K_S-pub` (with `K_CA-pub` to decrypt signature)
	- client generates a _session key_ (symmetric crypto) and sends back `{K_session}K_S-pub`
	- now only the client and server know the session key and it will be used for all communication (during the session)

####Spring MVC
- dispatcher _servlet_ maps a request to a handler -> controller -> view resolver -> view
- annotation driven request mapping in controller class `@RequestMapping( ... ) public String foo()`
- view resolver turns request map `/contacts/list` into internal resource `/WEB-INF/views/contacts/list.jsp`
- JSP pages allow us to build HTML dynamically using data from the Model `JSP page + model data -> JSP processor -> HTML page`


##C# Functional Programming
####Intro
- C# `class` vs `struct`
	- class variables are __pointers__ to an object
	- struct variables are __objects__
- `out` parameters act as additional return values `void foo( ... , out int r) { ... }`
- __implicitly typed__ variable `var` (still a _static_ type)
- `dynamic` parameters can be any type (runtime checks) `void foo(dynamic x) { x.bar(); }`
- `dynamic` `ExpandoObject` can be dynamically expanded at runtime
- classes can be split into separate chunks/files `partial class Foo { ... }`
- we can create and initialize __anonymous types__ as `var foo = new { X="bar", Y="foobar" };` 
- we can make a variable nullable with the `?` operator `int? x = null;`
- the `??` operator will use val1 if not null else val2 `int? x = val1 ?? val2;`
- we define a __sequence__ as implementing `IEnumerable`
- `yeild return;` will return, then when the method is called again it will __resume__ from AFTER the `yeild return;` statement
- this allows us to create __virtual sequences__ (that use _lazy evaluation_) -- the "sequence" doesn't actually exist until we call the enumerator `MoveNext()` (e.g. implicitly in a `foreach` loop)
- also allows the creation of __infinite sequences__ `for (int n = 0; ; n++) { yeild return n*n; }`
- `IEnumerable<out T>` interface __covariant__ in T -- we can assign a list of type derived to a sequence of base variable e.g. `IEnumerable<MyBase> myBases = new List<MyDerived>();`
- `IComparar<in T>` interface __contravariant__ in T-- we can assign a base comparer to a derived comparer variable e.g. `IComparer<MyDerived> comp = new MyBaseComparer();`
- variance of generic delegates: (B=base, D=derived)

| func pointer | function | result |
| -----------: | :------- | :----- |
| `B -> B` | `B -> D` | __covariance__ in _result_ type |
| `D -> D` | `B -> D` | __contravariance__ in _parameter_ type | 
| `D -> B` | `B -> D` | __contravariance__ in _parameter_ type and __covariance__ in _result_ type |
| `B -> D` | `B -> B` | _NOT_ safe |
| `B -> D` | `D -> D` | _NOT_ safe |
| `B -> D` | `D -> B` | _NOT_ safe |

- generic __constraints__ as `class FooList<T> where T : U`