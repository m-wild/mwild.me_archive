---
layout: post
title: CompSci 335 notes
category: uni
excerpt:
---

##Spring framework
####IoC
- Interfaces improve extensibility and flexibility
- IoC allows component implementations and binding requirements to be manages separately from application code
- DI involved IoC container injecting dependencies into components through constructor/setter injection
- IoC containers offer service interfaces (eg. ApplicationContext) to interact with them

####AOP
- AOP allows more effective management of cross-cutting concerns
- Spring uses dynamic AOP where advice is woven at run time via proxies
- Spring allows several types of advice (@Before, @AfterReturning, @Around, @AfterThrowing, etc)
- pointcuts identify the precise joinpoint where the advice should be inserted
- Introductions allow objects to implement additional interfaces at runtime
- dynamic proxies contain invocation handlers that apply advice (basis of AOP proxies)

####RMI + Distributed Objects
- the aim of RMI is to hide the details of invoking a method over a server, so it is the same as a local method to the developer
- however it is necessarily different - parameters must be serialized, there is additional runtime overhead, remote calls can fail
- client invokes methods on local proxy objects
- serializes/marshals the object/arguments -> turns memory references into handles (class handle, object handle), and outputs as a byte stream

####Web Services
- HTTP is an open, stateless, request-reply standard
- SOAP (simple object access protocol)
	- uses XML
	- WSDL (web service description language) uses XML to describe the web service (service contract), includes datatypes, messages, operations etc
	- action-focused
- REST (representational state transfer)
	- resource-focused
	- relatively lightweight
- Spring allows abstraction above HTTP, achieving separation of concerns and reducing boilerplate code

####Data Access
- DAO (data access object) reads/writes the database
- DAO interfaces allow testability + modifiability
- Data sources can be:
	- pooled: many active connections, threads can request one to use
	- on demand: new connection created when needed
	- singleton: one connection, suitable for small applications
- Simple JDBC (w/ spring)
	- Uses tired and tested SQL. Direct manipulation of tables, rows, columns
	- Complexity grows with persistence requirements
- ORM (object relational mapping)
	- automates mapping between objects and SQL structures
	- automates SQL query generation
	- allows developers to focus on application logic in terms of objects

####Transactions
- Transactions deal with currency control problems
	- lost updates (`T:x.setBalance, U:x.setBalance`)
	- inconsistent retrieval (`T:x.withdraw, U:x.getBalance+y.getBalance, T:y.setBalance`)	
- by default each individual SQL statement is a transaction, we need the client to be able to specify the transaction start/end
- RMI clients use middleware API to specify  transaction boundaries on RMI calls.
- ACID
	- __A__tomicity: transaction either completes successfully, or fails with _NO_ effect
	- __C__onsistency: transaction takes system from one consistent state to another
	- __I__solation: one transaction cannot interfere with others
	- __D__urability: after successful transaction all effects are saved in permanent storage
- _Serially equivalent_ interleaving -- has the same effect when run concurrently or serially
	- all pairs of conflicting operations must be executed in the same order at all the objects they both access (read-write, write-read, write-write)
- aborting
	- _dirty reads_ -- U sees write of T before T aborts; fix by _cascading aborts_
	- _premature writes_ -- leads to inconsistent data where a transaction aborts; keep a 'before image' snapshot, delay write operations until other transactions commit/abort
- exclusive locks -- fixes all 4 problems but slow the DB
- _read/write locks_
	- read lock _sharing_: multiple transactions can hold a read lock on the same object
	- lock _promotion_: read lock can be promoted to write lock

| lock set 	| req read 	| req write |
| :------- 	| :------- 	| :-------- |
| none		| OK 		| OK		|
| read 		| OK 		| WAIT		|
| write 	| WAIT 		| WAIT		|

- deadlock:
	- prevent: 
		- acquire all locks _atomically_ (restrictive, may be unknown)
		- request in a predefined order (difficult)
	- timeout (simple)
	- detection and removal (find cycles in waiting-for graph)
- distributed transactions (over multiple servers) require a 2-phase commit, managed by a transaction manager
- spring allows us to specify transactions _declaratively_, spring will do all the hard work
	- `<tx:annotation-driven transaction-manager="txManager"/>`
	- `@Transactional public void updateXYZ() { ... }` 
- propogation =
	- `REQUIRED` -- must use a transaction, will use existing (if exists) [default]
	- `MANDATORY` will only use an existing; `REQUIRES_NEW`
	- `SUPPORTS` will use (if exists) or wont
	- `NOT_SUPPORTED`; `NEVER` (throws ex)
- isolation =
	- `READ_UNCOMMITTED` (breaks ACID isolation),
	- `READ_COMMITTED` (repeatable reads can occur i.e. val changes mid transaction due to other trans commit),
	- `REPEATABLE_READ` (fixes this, but phantom reads still possible i.e. see different rows if other trans added),
	- `SERIALIZABLE` (concurrent at cost of performance)
- `rollback-for <T> extends Exception`

####Security
